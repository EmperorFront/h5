<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        body{
            padding:0;
            margin:0;
            overflow: hidden;
        }
        #cas{
            display: block;
            background-color:rgba(0,0,0,0);
            margin:auto;
            border:1px solid;
        }
    </style>
    <title></title>
</head>
<body>
<div >
    <canvas id='cas' width="800" height="600">浏览器不支持canvas</canvas>
    <div style="text-align:center">canvas简单图形（无缓存压测）</div>
    <div style="text-align:center">在简单图形下，canvas离屏缓存并没有优化计算量的效果，因此，不添加缓存负担每一帧可以支持到万级canvasAPI的调用，此为5000个，依旧可以稳定在60fps</div>
</div>

<script>
    var simpleCanvas = function() {
        var canvas = document.getElementById('cas'),
                ctx = canvas.getContext('2d'),
                squares = [];
        var square = function(x, y, r, vx, vy, color, useCache) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.r = r;
            this.color = color;
            this.cacheCanvas = document.createElement("canvas");
            this.cacheCtx = this.cacheCanvas.getContext("2d");
            this.cacheCanvas.width = this.r;
            this.cacheCanvas.height = this.r;
            this.useCache = useCache;
            if(useCache){
                this.cache();
            }
        }
        //一种牛逼的取整方式，比parseint代价小，parseint为处理浮点甚至转化了字符串
        function getZ(num){
            var rounded;
            rounded = (0.5 + num) | 0;
            // A double bitwise not.
            rounded = ~~ (0.5 + num);
            // Finally, a left bitwise shift.
            rounded = (0.5 + num) << 0;
            return rounded;
        }
        square.prototype = {
            paint: function(ctx) {
                if(!this.useCache){
                    ctx.save();
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.r, this.r);
                    ctx.restore();
                } else {
                    ctx.drawImage(this.cacheCanvas, this.x, this.y, this.cacheCanvas.width, this.cacheCanvas.height);
                }
            },
            move: function() {
                this.x += this.vx;
                this.y += this.vy;
                if(this.x>(canvas.width-this.r)||this.x<this.r){
                    this.x=this.x<this.r?this.r:(canvas.width-this.r);
                    this.vx = -this.vx;
                }
                if(this.y>(canvas.height-this.r)||this.y<this.r){
                    this.y=this.y<this.r?this.r:(canvas.height-this.r);
                    this.vy = -this.vy;
                }
                this.paint(ctx);
            },
            cache: function() {
                this.cacheCtx.fillStyle = this.color;
                this.cacheCtx.fillRect(0, 0, this.r, this.r);
            }
        }
        var Game = {
            init:function(){
                for(var i=0;i<5000;i++){
                    var s = new square(getRandom(0,canvas.width) , getRandom(0,canvas.height) ,getRandom(5 , 20) , getRandom(-3 , 3) ,  getRandom(-1 , 1), '#' + getZ(getRandom(99 , 999)) , 0)
                    squares.push(s);
                }
            },
            update:function(){
                ctx.clearRect(0,0,canvas.width,canvas.height);
                for(var i=0;i<squares.length;i++){
                    squares[i].move();
                }
            },
            loop:function(){
                var _this = this;
                this.update();
//                stats.update();
                RAF(function(){
                    _this.loop();
                })
            },
            start:function(){
                this.init();
                this.loop();
            }
        };
        window.RAF = (function(){
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {window.setTimeout(callback, 1000 / 60); };
        })();
        return Game;
    }();
    function getRandom(a , b){
        return Math.random()*(b-a)+a;
    }
    window.onload = function(){
        simpleCanvas.start();
    }
</script>
</body>
</html>
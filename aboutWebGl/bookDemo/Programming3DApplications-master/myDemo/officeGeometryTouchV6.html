<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>打飞机，你能坚持多久？</title>

    <style>
        .sight {
            margin: auto;
            position: absolute;
            top: 0px;
            left: 0px;
            bottom: 0;
            right: 0;
        }
        .tip {
            margin: auto;
            position: absolute;
            top: 316px;
            left: 17px;
            bottom: 0;
            right: 0;
            width: 500px;
            height: 68px;
            text-align: center;
        }
    </style>
    <script src="../libs/jquery-1.9.1/jquery-1.9.1.js"></script>
    <script src="../libs/three.js.r58/threeDemoUse.js"></script>
    <script src="../libs/three.js.r58/controls/DeviceOrientationControls.js"></script>
    <script src="../libs/requestAnimationFrame/RequestAnimationFrame.js"></script>
    <script src="myExamnation/threejsloader/OBJLoader.js"></script>

    <script type="text/javascript">
//v6版本增加了大炮逻辑，和弹道1.0版本，在单子弹快速射击的情况下无感知，但实际上是假的。

        var canvas;

        //视角场景
        var renderer = null;
        var environmentScene = {
                    scene : null,
                    camera : null,
                    //重感控制器
                    DeviceOrientationControls : null,
                    //点击体方块合集，点击逻辑要用
                    clickGeomoryCube : null,
                    //点击体threeobject飞机合集，点击逻辑用
                    clickGeomoryAirplane : null,
                    //物体属性集合
                    cubes : [],
                    //飞机属性集合
                    airplanes : [],
                    //var recycles = [];//每一帧中被回收掉的飞机。
            },
            playerScene = {
                scene : null,
                camera : null,
                gun : null,
                //一次性初始化10发子弹，用于表现射击
                bullets : []
            };

        var mouse = new THREE.Vector2(), INTERSECTED;

        //资源加载完成成功标识符，用于启动载入页的是否结束的判断依据
        //每个资源的加载成功回调续上sourcesLoad检测算法，若final为1，则可以执行
        var sourcesLoad = {
            final : 0,
            sources : {
                objGun : 0
            }
        }
        function sourcesLoadCheck() {
            for (var key in sourcesLoad.sources) {
                if( sourcesLoad.sources[key] == 1){
                    //当前值为1，则final暂定为1
                    sourcesLoad.final = 1;
                } else {
                    sourcesLoad.final = 0;
                    break;
                }
            }
        }


        //警告框
        var _tip = null;

        //调色板
        var Colors = {
            red:0xf25346,
            white:0xd8d0d1,
            brown:0x59332e,
            pink:0xF5986E,
            brownDark:0x23190f,
            blue:0x68c3c0,
            yellow:0xFFD700,
        };

        //创建小点击几何体
        function createCubes() {

            environmentScene.clickGeomoryCube = new THREE.Object3D;

            function addCubes(times){
                for(var i = 0; i < times; i++ ){
                    var cubeGeometry = new THREE.BoxGeometry(10,10,10);
                    var cubeMaterial = new THREE.MeshLambertMaterial({color:0xff0000});
                    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    environmentScene.cubes.push(cube);
                    cube.position.set(getRandom(800), getRandom(800), getRandom(800));

                    environmentScene.clickGeomoryCube.add(cube);
                }
                environmentScene.scene.add(environmentScene.clickGeomoryCube);
            }
            addCubes(10);
        }
        //传入一个数字，返回其绝对值范围内的随机整数。
        function getRandom (absolute) {
            return parseInt(Math.random() * absolute * 2 - absolute);
        }
        //传入一个正整数，返回其绝对值范围内的随机负整数
        function getRandomMinus (absolute){
            return -Math.abs(parseInt(Math.random() * absolute));
        }

        //创建一个tank飞机(血量高，飞行慢)
        var AirPlane_tank = function(config) {
            this.speed = config.speed ? config.speed : 0.4;
            this.blood = config.blood ? config.blood : 90;

            //init飞机的方法没必要每个飞机都绑定一个自己的，可以抽取成公共函数。。。后续改造
            this.initAirplane = function() {
                //处理关于打击的参量
                this.initShoot();
                //处理关于旋转组件重组的参量
                this.initComponent();
            }
            this.initShoot = function() {
                this.shootingTimes = 0;
                this.shooted = 0;
            }
            this.initComponent = function() {
                for(var j = 0; j < this.mesh.children.length; j++){
                    this.mesh.children[j].position.set(
                            this.mesh.children[j].initPosition[0],
                            this.mesh.children[j].initPosition[1],
                            this.mesh.children[j].initPosition[2]
                    );
                    this.mesh.children[j].rotation.x = 0;
                }
            }

            this.mesh = new THREE.Object3D();

            // 创建机舱
            var geomCockpit = new THREE.BoxGeometry(60,50,50,1,1,1);
            var matCockpit = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
            cockpit.initPosition = [0,0,0];
            cockpit.position.set(0,0,0);
            cockpit.castShadow = true;
            cockpit.receiveShadow = true;
            cockpit.broken = {
                rotation : getRandom(8)/100,
                position : [getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(cockpit);

            // 创建发动机
            var geomEngine = new THREE.BoxGeometry(20,50,50,1,1,1);
            var matEngine = new THREE.MeshPhongMaterial({color:Colors.white, shading:THREE.FlatShading});
            var engine = new THREE.Mesh(geomEngine, matEngine);
            engine.initPosition = [40,0,0];
            engine.position.x = 40;
            engine.castShadow = true;
            engine.receiveShadow = true;
            engine.broken = {
                rotation : getRandom(8)/100,
                position : [40 + getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(engine);

            // 创建机尾
            var geomTailPlane = new THREE.BoxGeometry(15,20,5,1,1,1);
            var matTailPlane = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);
            tailPlane.initPosition = [-35,25,0];
            tailPlane.position.set(-35,25,0);
            tailPlane.castShadow = true;
            tailPlane.receiveShadow = true;
            tailPlane.broken = {
                rotation : getRandom(8)/100,
                position : [-35 + getRandom(50), 25 + getRandom(50), getRandom(50)]
            }
            this.mesh.add(tailPlane);

            // 创建机翼
            var geomSideWing = new THREE.BoxGeometry(40,8,150,1,1,1);
            var matSideWing = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            var sideWing = new THREE.Mesh(geomSideWing, matSideWing);
            sideWing.initPosition = [0,0,0];
            sideWing.castShadow = true;
            sideWing.receiveShadow = true;
            sideWing.broken = {
                rotation : getRandom(8)/100,
                position : [getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(sideWing);

            // 创建螺旋桨
            var geomPropeller = new THREE.BoxGeometry(20,10,10,1,1,1);
            var matPropeller = new THREE.MeshPhongMaterial({color:Colors.brown, shading:THREE.FlatShading});
            var propeller = new THREE.Mesh(geomPropeller, matPropeller);
            propeller.initPosition = [50,0,0];
            propeller.position.set(50,0,0);
            propeller.castShadow = true;
            propeller.receiveShadow = true;
            propeller.broken = {
                rotation : getRandom(8)/100,
                position : [50 + getRandom(50), getRandom(50), getRandom(50)]
            }

            // 螺旋桨与轴体的组合
            var geomBlade = new THREE.BoxGeometry(1,100,20,1,1,1);
            var matBlade = new THREE.MeshPhongMaterial({color:Colors.brownDark, shading:THREE.FlatShading});

            var blade = new THREE.Mesh(geomBlade, matBlade);
            blade.initPosition = [8,0,0];
            blade.position.set(8,0,0);
            blade.broken = {
                rotation : getRandom(8)/100,
                position : [8 + getRandom(5), getRandom(5), getRandom(5)]
            }
            blade.castShadow = true;
            blade.receiveShadow = true;
            propeller.add(blade);

            this.mesh.add(propeller);

            this.shootingTimes = 0;
        };

        //创建一个sailer飞机(血量低，飞行快)
        var AirPlane_sailer = function(config) {
            this.speed = config.speed ? config.speed : 0.8;
            this.blood = config.blood ? config.blood : 30;

            this.initAirplane = function(){
                //处理关于打击的参量
                this.initShoot();
                //处理关于旋转组件重组的参量
                this.initComponent();
            }
            this.initShoot = function() {
                this.shootingTimes = 0;
                this.shooted = 0;
            }
            this.initComponent = function() {
                for(var j = 0; j < this.mesh.children.length; j++){
                    this.mesh.children[j].position.set(
                            this.mesh.children[j].initPosition[0],
                            this.mesh.children[j].initPosition[1],
                            this.mesh.children[j].initPosition[2]
                    );
                    this.mesh.children[j].rotation.x = 0;
                }
            }

            this.mesh = new THREE.Object3D();

            // 创建机舱
            var geomCockpit = new THREE.BoxGeometry(80,50,50,1,1,1);
            var matCockpit = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            //收紧尾部屁股顶点
            geomCockpit.vertices[4].y-=10;
            geomCockpit.vertices[4].z+=20;
            geomCockpit.vertices[5].y-=10;
            geomCockpit.vertices[5].z-=20;
            geomCockpit.vertices[6].y+=30;
            geomCockpit.vertices[6].z+=20;
            geomCockpit.vertices[7].y+=30;
            geomCockpit.vertices[7].z-=20;

            var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
            cockpit.castShadow = true;
            cockpit.receiveShadow = true;
            cockpit.initPosition = [0,0,0];
            cockpit.broken = {
                rotation : getRandom(8)/100,
                position : [getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(cockpit);

            // 创建发动机
            var geomEngine = new THREE.BoxGeometry(20,50,50,1,1,1);
            var matEngine = new THREE.MeshPhongMaterial({color:Colors.yellow, shading:THREE.FlatShading});
            var engine = new THREE.Mesh(geomEngine, matEngine);
            engine.initPosition = [40,0,0];
            engine.position.x = 40;
            engine.castShadow = true;
            engine.receiveShadow = true;
            engine.broken = {
                rotation : getRandom(8)/100,
                position : [40 + getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(engine);

            // 创建机尾
            var geomTailPlane = new THREE.BoxGeometry(15,20,5,1,1,1);
            var matTailPlane = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);
            tailPlane.initPosition = [-45,25,0];
            tailPlane.position.set(-45,25,0);
            tailPlane.castShadow = true;
            tailPlane.receiveShadow = true;
            tailPlane.broken = {
                rotation : getRandom(8)/100,
                position : [-35 + getRandom(50), 25 + getRandom(50), getRandom(50)]
            }
            this.mesh.add(tailPlane);

            // 创建机翼
            var geomSideWing = new THREE.BoxGeometry(40,8,150,1,1,1);
            var matSideWing = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
            var sideWing = new THREE.Mesh(geomSideWing, matSideWing);
            sideWing.castShadow = true;
            sideWing.receiveShadow = true;
            sideWing.initPosition = [0,0,0];
            sideWing.broken = {
                rotation : getRandom(8)/100,
                position : [getRandom(50), getRandom(50), getRandom(50)]
            }
            this.mesh.add(sideWing);

            // 创建螺旋桨
            var geomPropeller = new THREE.BoxGeometry(20,10,10,1,1,1);
            var matPropeller = new THREE.MeshPhongMaterial({color:Colors.blue, shading:THREE.FlatShading});
            var propeller = new THREE.Mesh(geomPropeller, matPropeller);
            propeller.initPosition = [50,0,0];
            propeller.position.set(50,0,0);
            propeller.castShadow = true;
            propeller.receiveShadow = true;
            propeller.broken = {
                rotation : getRandom(8)/100,
                position : [50 + getRandom(50), getRandom(50), getRandom(50)]
            }

            // 螺旋桨叶片及轴体
            var geomBlade = new THREE.BoxGeometry(1,100,20,1,1,1);
            var matBlade = new THREE.MeshPhongMaterial({color:Colors.brownDark, shading:THREE.FlatShading});

            var blade = new THREE.Mesh(geomBlade, matBlade);
            blade.initPosition = [8,0,0];
            blade.position.set(8,0,0);
            blade.broken = {
                rotation : getRandom(8)/100,
                position : [8 + getRandom(5), getRandom(5), getRandom(5)]
            }
            blade.castShadow = true;
            blade.receiveShadow = true;
            propeller.add(blade);

            this.mesh.add(propeller);

            //创建飞行员
            var thePilot = pilot(new THREE.Object3D());
            thePilot.initPosition = [-10,27,0];
            thePilot.position.set(-10,27,0);
            thePilot.broken = {
                rotation : getRandom(8)/100,
                position : [8 + getRandom(5), getRandom(5), getRandom(5)]
            }
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
            this.mesh.add(thePilot);

            function pilot(thePilot){
                thePilot = new THREE.Object3D();
                thePilot.name = "pilot";

                // 用于实现随风飞舞的头发
                thePilot.angleHairs=0;

                // 飞行员身体
                var bodyGeom = new THREE.BoxGeometry(15,15,15);
                var bodyMat = new THREE.MeshPhongMaterial({color:Colors.brown, shading:THREE.FlatShading});
                var body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.set(2,-12,0);
                thePilot.add(body);

                // 飞行员脸部
                var faceGeom = new THREE.BoxGeometry(10,10,10);
                var faceMat = new THREE.MeshLambertMaterial({color:Colors.pink});
                var face = new THREE.Mesh(faceGeom, faceMat);
                thePilot.add(face);

                // 飞行员头发
                var hairGeom = new THREE.BoxGeometry(4,4,4);
                var hairMat = new THREE.MeshLambertMaterial({color:Colors.brown});
                var hair = new THREE.Mesh(hairGeom, hairMat);
                // Align the shape of the hair to its bottom boundary, that will make it easier to scale.
                hair.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,2,0));

                // 头发的容器
                var hairs = new THREE.Object3D();

                // 头发顶部的容器
                // 用于动画
                thePilot.hairsTop = new THREE.Object3D();

                // 创建头发
                // 3*4的网格中定位
                for (var i=0; i<12; i++){
                    var h = hair.clone();
                    var col = i%3;
                    var row = Math.floor(i/3);
                    var startPosZ = -4;
                    var startPosX = -4;
                    h.position.set(startPosX + row*4, 0, startPosZ + col*4);
                    thePilot.hairsTop.add(h);
                }
                hairs.add(thePilot.hairsTop);

                // 随风飞舞的头发动画
                var hairSideGeom = new THREE.BoxGeometry(12,4,2);
                hairSideGeom.applyMatrix(new THREE.Matrix4().makeTranslation(-6,0,0));
                var hairSideR = new THREE.Mesh(hairSideGeom, hairMat);
                var hairSideL = hairSideR.clone();
                hairSideR.position.set(8,-2,6);
                hairSideL.position.set(8,-2,-6);
                hairs.add(hairSideR);
                hairs.add(hairSideL);

                // 头后边的头发
                var hairBackGeom = new THREE.BoxGeometry(2,8,10);
                var hairBack = new THREE.Mesh(hairBackGeom, hairMat);
                hairBack.position.set(-1,-4,0)
                hairs.add(hairBack);
                hairs.position.set(-5,5,0);

                thePilot.add(hairs);

                var glassGeom = new THREE.BoxGeometry(5,5,5);
                var glassMat = new THREE.MeshLambertMaterial({color:Colors.brown});
                var glassR = new THREE.Mesh(glassGeom,glassMat);
                glassR.position.set(6,0,3);
                var glassL = glassR.clone();
                glassL.position.z = -glassR.position.z

                var glassAGeom = new THREE.BoxGeometry(11,1,11);
                var glassA = new THREE.Mesh(glassAGeom, glassMat);
                thePilot.add(glassR);
                thePilot.add(glassL);
                thePilot.add(glassA);

                var earGeom = new THREE.BoxGeometry(2,3,2);
                var earL = new THREE.Mesh(earGeom,faceMat);
                earL.position.set(0,0,-6);
                var earR = earL.clone();
                earR.position.set(0,0,6);
                thePilot.add(earL);
                thePilot.add(earR);

                return thePilot;
            }

            this.shootingTimes = 0;
        };

        //将飞机追加到场景中去。
        function createPlane(){

            environmentScene.clickGeomoryAirplane = new THREE.Object3D;

            function addPlanes(times){
                for(var i = 0; i < times.maxtimes; i++ ){
                    var airplane_sailer, airplane_tank;

                    if(i < times.airplane_sailer){
                        airplane_sailer = new AirPlane_sailer({});
                        airplane_sailer.mesh.scale.set(.25,.25,.25);
                        airplane_sailer.mesh.position.y = getRandom(150);
                        airplane_sailer.mesh.position.x = getRandom(150);
                        airplane_sailer.mesh.position.z = getRandomMinus(700) - 700;

                        airplane_sailer.mesh.rotation.y = -1.57;
                        environmentScene.airplanes.push(airplane_sailer);
                        environmentScene.clickGeomoryAirplane.add(airplane_sailer.mesh);
                    }
                    if(i < times.airplane_sailer){
                        airplane_tank = new AirPlane_tank({});
                        airplane_tank.mesh.scale.set(.25,.25,.25);
                        airplane_tank.mesh.position.y = getRandom(300);
                        airplane_tank.mesh.position.x = getRandom(300);
                        airplane_tank.mesh.position.z = getRandomMinus(500) - 500;

                        airplane_tank.mesh.rotation.y = -1.57;
                        environmentScene.airplanes.push(airplane_tank);
                        environmentScene.clickGeomoryAirplane.add(airplane_tank.mesh);
                    }
                }
                environmentScene.scene.add(environmentScene.clickGeomoryAirplane);
                console.log(environmentScene.airplanes);
            }
            //机群可以随时以此方式增加
            addPlanes({maxtimes:20, airplane_sailer:20, airplane_tank:10});
        }





        //创建用户场景
        playerScene.scene = new THREE.Scene();
        function initPlayerScene( canvas ) {
            //添加光照相机等
            var spotLight = new THREE.PointLight(0xffffff);
            spotLight.position.set(-30, 40, 50);
            spotLight.intensity = 1;
            playerScene.scene.add(spotLight);

            playerScene.camera = new THREE.PerspectiveCamera( 75, canvas.width / canvas.height, 0.1, 500 );
            playerScene.camera.position.set(0,0,0);
            playerScene.camera.lookAt(0,0,-1);

            playerScene.gun = new gunThump({});
            initGun(playerScene.gun);


            //子弹改用小圆柱代替，无法深复制一个大数组。。另，尽快开始记分牌的制作。
            //创建10枚子弹
            for(var i = 0; i < 10; i++) {
                var thebullet = new bullet({});
                initBullet(thebullet);
            }
            //createObjBullets(10);
           //playerScene.bullets[2].position.set(0, 0 , -0.1);
            //playerScene.scene.add(playerScene.bullets[2]);
        }



        var rotationBox = new THREE.Object3D();
        rotationBox.position.set(0.6,-1.5,-1.0);
        rotationBox.rotation.z = 0;


        //创建一个重击炮
        var gunThump = function(config) {
            //一些属性
            //前后抖动一次，旋转一下
            this.animationData = {
                //回缩时长
                shake: config.shake ? config.shake : 3,
                //旋转时长，暂定一旦按住永远旋转
                rotate : config.rotate ? config.rotate : 30,
                //是否正在回缩
                shakeing : 'back',
                //是否正在旋转
                rotateing : 1,
                //已回缩时长
                shakeTimes : 0,
                //已旋转时长
                rotateTimes : 0,
                //每两次回缩发射一枚子弹
                shoot : 0,

                //存储为了旋转而构建的3D单元
                //rotationBox :
            }

            //炮的皮肤
            this.skin = new THREE.Texture();
            //模型
            this.model = null;
            //重击炮动画
            this.fireAnimation = function(_this) {

                //回缩动画
                if(_this.animationData.shakeing == 'back') {
                    if(_this.animationData.shake > _this.animationData.shakeTimes) {
                        //debugger;
                        _this.model.position.z += 0.009;
                        _this.animationData.shakeTimes ++;
                    } else {
                        //后移完成,初始化
                        _this.animationData.shakeing = 'front'
                        _this.animationData.shakeTimes = 0;
                    }
                }

                //前伸动画,半速前伸
                if(_this.animationData.shakeing == 'front') {
                    if(_this.animationData.shake * 3 > _this.animationData.shakeTimes) {
                        _this.model.position.z -= 0.003;
                        _this.animationData.shakeTimes ++;
                    } else {
                        //前伸完成,初始化
                        _this.animationData.shakeing = 'back'
                        _this.animationData.shakeTimes = 0;

                        //发射子弹倒计时，倒计时重铸在子弹发射逻辑中。
                        _this.animationData.shoot --;
                    }
                }
                rotationBox.add(_this.model);
                //旋转动画(收起枪？？)
                if(_this.animationData.rotateing) {


                    //mm = changePivot(0.6,-1.5,-1.4,_this);
                    //rotationBox.rotation.x += 0.03;


                    //外部抄的旋转函数通过x,y,z指定旋转中心，obj是要旋转的对象,没用了
//                    function changePivot(x,y,z,obj){
//                        var wrapper = new THREE.Object3D();
//                        wrapper.position.set(x,y,z);
//                        wrapper.add(obj);
//                        obj.position.set(-x,-y,-z);
//                        return wrapper;
//                    }


                }
            }
        }

        //炮的init方法
        function initGun(_this){
            var _this = _this;
            //纹理
            var gunSkinImageLoader = new THREE.ImageLoader();
            gunSkinImageLoader.load( 'myExamnation/3Dmodel/metal3.jpg', function ( image ) {
                _this.skin.image = image;
                _this.skin.needsUpdate = true;
            } );

            //模型
            var gunOBJLoader = new THREE.OBJLoader();
            gunOBJLoader.load('myExamnation/3Dmodel/gun.obj', function (geometry) {
                var material = new THREE.MeshLambertMaterial();
                _this.model = geometry;

                //加载模型指定Texture
                _this.model.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material.map = _this.skin;
                    }
                } );
                _this.model.position.set(0.257,-0.7,-1.4);

                _this.model.scale.set(0.03, 0.03, 0.03);
                _this.model.rotation.y = Math.PI/2;

                //这里一定要放这里激活。。竟然是异步的。。。
                //playerScene.scene.add(_this.model);
                playerScene.scene.add(rotationBox);

                //gunObj模型加载完毕
                sourcesLoad.sources.objGun = 1;
                sourcesLoadCheck();
            });
        }




        var bullet = function (config){
            //子弹速度
            this.speed = config.speed ? config.speed : 5;
            //子弹的皮肤
            this.skin = null;
            //模型
            this.model = null;
            //子弹状态,0为回收池中待发射，1为发射中
            this.state = 0;
        }
        //子弹的init方法
        function initBullet(theBullet) {
            //小圆锥
            var geometry = new THREE.CylinderGeometry( 0.8, 0.25, 4, 32 );
            //小圆锥皮肤
            var material = new THREE.MeshLambertMaterial( {color: 0xffff00} );
            cylinder = new THREE.Mesh( geometry, material );

            //转向
            cylinder.rotation.z = -Math.PI/25;
            cylinder.rotation.x = Math.PI/2;

            cylinder.position.set(9,-23,-50);
            theBullet.model = cylinder;

            //完成初始化子弹则将子弹放入池子。
            playerScene.bullets.push(theBullet);
        }

        function bulletAnnimation() {
            var theBullet;
            //各种子弹状态。
            for(var i = 0; i < playerScene.bullets.length; i++){
                theBullet = playerScene.bullets[i];
                //处理发射中的子弹
                if(playerScene.bullets[i].state == 1) {
                    //计算子弹轨迹
                    bulletTrack(theBullet);
                }

                //发射子弹,当炮倒计时为0发射
                if(playerScene.gun.animationData.shoot <= 0) {
                    bulletShoot(theBullet);
                }
            }

            //子弹轨迹
            function bulletTrack(theBullet) {
                theBullet.model.position.z -= theBullet.speed;
                //横轴偏量
                theBullet.model.position.x -= theBullet.speed * 0.03;
                //纵轴偏量
                theBullet.model.position.y += theBullet.speed * 0.08;

                //回收,超过视觉边界回收掉。
                if(theBullet.model.position.z < -500 ) {
                    theBullet.state = 0;
                }
            }
            function bulletShoot(theBullet) {
                //取出一枚子弹
                if(theBullet.state == 0){
                    //放入场景，开始弹道计算
                    theBullet.model.position.set(9,-23,-50);
                    theBullet.state = 1;
                    playerScene.scene.add(theBullet.model);
                    //重铸倒计时
                    playerScene.gun.animationData.shoot = 2;
                }
            }

        }

        //该方法闲置,未能解决同对象的深复制问题
        function createObjBullets(times) {
            //子弹皮肤
            var bulletTexture = new THREE.Texture();
            var bulletLoader = new THREE.ImageLoader();
            bulletLoader.load( 'myExamnation/3Dmodel/bulletSkinBlack.jpg', function ( image ) {
                bulletTexture.image = image;
                bulletTexture.needsUpdate = true;
            } );
            var bulletLoader = new THREE.OBJLoader();
            bulletLoader.load('myExamnation/3Dmodel/bullet.obj', function (theBullet) {
                var oneBullet;
                oneBullet = deepCopy(theBullet,oneBullet)
                onLoad(oneBullet);
            });

            function onLoad(theBullet) {
                for(var i = 0; i < times; i++) {
                    onLoadJob(theBullet);
                }
                playerScene.bullets[3].position.set(0, 1 , -10);
                playerScene.scene.add(playerScene.bullets[2]);
            }

            function onLoadJob(theBullet) {
                //加载模型如何指定Texture呢？
                theBullet.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.material.map =  bulletTexture;
                    }
                } );

                theBullet.scale.set(0.003, 0.003, 0.003);

                theBullet.position.set(0, 0 , -10);

                    var cloneObj = theBullet;
                    playerScene.bullets.push(theBullet);
            }
        }






        function createEnvironmentScene(canvas) {
            renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
            renderer.setSize(canvas.width, canvas.height);
            environmentScene.scene = new THREE.Scene();
            //添加透视相机
            environmentScene.camera = new THREE.PerspectiveCamera( 75, canvas.width / canvas.height, 0.1, 1000 );
            environmentScene.camera.position.set(0,0,0);
            //var helper = new THREE.CameraHelper( environmentScene.camera );
            //environmentScene.scene.add( helper );
            environmentScene.scene.add(environmentScene.camera);

            // Add a directional light to show off the object
            var pointLight = new THREE.PointLight( 0xffffff, 1 );
            pointLight.position.set(0, 100, 0);
            environmentScene.scene.add( pointLight );

            //创建天空盒映射材质
            var envMap = null;
            function createMaterials() {
                var path = "img/";
                var urls = [ path + "riverside_w.png", path + "riverside_e.png",
                    path + "riverside_up.png", path + "riverside_down.png",
                    path + "riverside_s.png", path + "riverside_n.png" ];
                envMap = THREE.ImageUtils.loadTextureCube( urls );
            }
            createMaterials();

            // 创建天空盒
            var shader = THREE.ShaderLib[ "cube" ];
            shader.uniforms[ "tCube" ].value = envMap;
            var material = new THREE.ShaderMaterial( {
                        fragmentShader: shader.fragmentShader,
                        vertexShader: shader.vertexShader,
                        uniforms: shader.uniforms,
                        side: THREE.BackSide
                    } ),
                    mesh = new THREE.Mesh( new THREE.CubeGeometry( 1000, 1000, 1000 ), material );
            environmentScene.scene.add( mesh );

            //添加点击几何体
            createCubes();
            createPlane();
        }
        function initControls()
        {
            environmentScene.DeviceOrientationControls = new THREE.DeviceOrientationControls( environmentScene.camera );


            //这几行含义未知
            raycaster = new THREE.Raycaster();

            //下边是渲染器
            //renderer = new THREE.WebGLRenderer();
            //renderer.setClearColor( 0xf0f0f0 );
            //renderer.setPixelRatio( window.devicePixelRatio );
            //renderer.setSize( window.innerWidth, window.innerHeight );
//        renderer.sortObjects = false;
            container.appendChild(renderer.domElement);


            //启动对鼠标的监听
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        }
        function onDocumentMouseMove( event ) {
            mouse.x =0;// ( event.clientX / canvas.width ) * 2 - 1;
            mouse.y =0;// - ( event.clientY / canvas.height ) * 2 + 1;
        }

        function run() {
            //每一帧递归调用
            requestAnimationFrame(function() { run(); });
            //分别处理每一种类型下的每一个物品
            var theAirplane
            for(var i = 0; i < environmentScene.airplanes.length; i++) {
                //查找过多，增加一个局域变量
                theAirplane = environmentScene.airplanes[i];
                //弹药匣旋转
                caissons();
                //处理正在飞行的飞机
                flyingAirplanes(theAirplane);
                //处理正在被攻击的飞机
                beShooting(theAirplane);
                //处理被击飞的飞机
                beShooted(theAirplane);
                //超出屏幕的飞机回收
                recycling(theAirplane);

            }

            //资源依赖类需检测资源是否已完备
            if( sourcesLoad.final ) {
                //火炮动画
                playerScene.gun.fireAnimation(playerScene.gun);
            }
            //子弹动画
            bulletAnnimation();

            //弹药匣
            function caissons() {
                if(environmentScene.cubes[i]){
                    environmentScene.cubes[i].rotation.x += 0.02;
                    environmentScene.cubes[i].rotation.y += 0.02;
                    environmentScene.cubes[i].rotation.z += 0.02;
                }
            }

            //飞机飞行
            function flyingAirplanes(theAirplane) {
                //4螺旋桨 5机翼
                theAirplane.mesh.children[4].rotation.x += 0.35;
                theAirplane.mesh.position.z += theAirplane.speed;
            }
            //被打击动画
            function beShooting(theAirplane) {
                if(theAirplane.shooting > 0){
                    //shooting属性 》0 位被打击状态
                    if(theAirplane.shootingTimes % 10 < 5){
                        theAirplane.mesh.rotation.y += 0.1;
                    } else {
                        theAirplane.mesh.rotation.y -= 0.1;
                    }
                    theAirplane.shooting = 0;
                }
            }
            //被击飞动画
            function beShooted(theAirplane) {
                theAirplane.shooting = 0;
                //解体并旋转坠落
                if(theAirplane.shooted == 1){

                    for(var j = 0; j < theAirplane.mesh.children.length; j++){
                        //解体，每个部件重新放位子
                        theAirplane.mesh.children[j].position.set(
                                theAirplane.mesh.children[j].broken.position[0],
                                theAirplane.mesh.children[j].broken.position[1],
                                theAirplane.mesh.children[j].broken.position[2]);

                        //坠落，每个部件自行旋转
                        theAirplane.mesh.children[j].rotation.x += theAirplane.mesh.children[j].broken.rotation;
                        theAirplane.mesh.position.y -= 0.5;
                        //theAirplane.mesh.position.y += 2;
                    }
                }
            }

            //回收机制，当某一轴位置超过某值则回收掉
            function recycling(theAirplane) {
                //过界回收，Z低于盒子下边界或X，Y超过创立边界即重赋值初始化该飞机
                if(theAirplane.mesh.position.y < -500 || Math.abs(theAirplane.mesh.position.x) > 1500 || Math.abs(theAirplane.mesh.position.z) > 1500) {
                    reinitAirplane(theAirplane);
                }
            }
            //当回收掉飞机后需要重新初始化部分相应值
            function reinitAirplane(airplane) {
                airplane.mesh.position.set(getRandom(150),getRandom(150),getRandomMinus(700) - 700);
                airplane.mesh.rotation.y = -1.57;
                airplane.initAirplane();
            }


//            设定射线，传入鼠标，相机。
            raycaster.setFromCamera( mouse, environmentScene.camera );
            //交叉的正方体
            var intersectsCube = raycaster.intersectObjects( environmentScene.clickGeomoryCube.children );
            //交叉的飞机
            var intersectsAirplaneBlock = [];
            for(var i = 0; i < environmentScene.clickGeomoryAirplane.children.length; i++ ){
                //查找过多，增加一个局域变量
                theAirplane = environmentScene.airplanes[i];

                var temp_intersectsAirplane = raycaster.intersectObjects( environmentScene.clickGeomoryAirplane.children[i].children );
                if(temp_intersectsAirplane.length){
                    intersectsAirplaneBlock = temp_intersectsAirplane;

                    //是否是可射击的
                    if(!theAirplane.shooted){
                        theAirplane.shooting = 1;
                        theAirplane.shootingTimes += 1;
                    }

                    //飞机血量
                    if(theAirplane.shootingTimes > theAirplane.blood){
                        theAirplane.shooted = 1;
                    }

                }
            }
            //正方体
            if ( intersectsCube.length > 0 ) {
                if ( INTERSECTED != intersectsCube[ 0 ].object ) {
                    if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                    INTERSECTED = intersectsCube[ 0 ].object;
                    //debugger;
                    //console.log(intersectsCube);
                    INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    //debugger;
                    INTERSECTED.material.emissive.setHex( 0xffffff );
                    //debugger;
                    //INTERSECTED.material.emissive.delate();


                }
            } else {
                // console.log(intersectsCube);
                //if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                //INTERSECTED = null;
            }
            //飞机
            if ( intersectsAirplaneBlock.length > 0 ) {
                if ( INTERSECTED != intersectsAirplaneBlock[ 0 ].object ) {
                    if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                    INTERSECTED = intersectsAirplaneBlock[ 0 ].object;
                    //debugger;
                    //console.log(intersectsCube);
                    INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    //debugger;
                    INTERSECTED.material.emissive.setHex( 0xffffff );
                    //debugger;
                    //INTERSECTED.material.emissive.delate();


                }
            } else {
                // console.log(intersectsCube);
                //if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                //INTERSECTED = null;
            }

            renderer.autoClear = false;
            renderer.render( environmentScene.scene, environmentScene.camera );
            //相机可能要换
            renderer.render( playerScene.scene, playerScene.camera );

            environmentScene.DeviceOrientationControls.update();
        }

        $(document).ready(
                function() {
                    window.addEventListener('resize', handleWindowResize, false);

                    //加载完，把选择框jq对象放入内存。
                    _tip = $(".tip");

                    //游戏加载提醒，横屏体验最佳，飞机有可能在任意方向出现
                    setTimeout(function(){showTip("<h2 style='color: red'>！！！敌机来袭！！！</h2>", 2000)}, 2500);

                    var _canvas = $("#webglcanvas");
                    _canvas.attr("width",document.body.clientWidth);
                    _canvas.attr("height",document.body.clientHeight);


                    window.addEventListener('deviceorientation', function(event) {
                        html = '';
                        alpha = event.alpha;
                        beta = event.beta;
                        gamma = event.gamma;
                    }, false)
                    canvas = document.getElementById("webglcanvas");

                    _canvas.click(function (event) {
                        event.preventDefault();
                    });

                    createEnvironmentScene(canvas);
                    initPlayerScene(canvas);
                    initControls();
                    run();
                }
        );

        function handleWindowResize() {
            HEIGHT = window.innerHeight;
            WIDTH = window.innerWidth;
            renderer.setSize(WIDTH, HEIGHT);
            environmentScene.camera.aspect = WIDTH / HEIGHT;
            environmentScene.camera.updateProjectionMatrix();
        }
        //展示提示 展示内容，时间（毫秒）
        function showTip(html,time) {
            _tip.html(html);
            setTimeout(function(){
                _tip.html("");
            },time);
        };


        //tool
        //需要深复制函数
        function deepCopy(o,c){
            var c = c || {}
            for(var i in o){
                if(typeof o[i] === 'object'){
                    //要考虑深复制问题了
                    if (o[i] == null){
                        c[i] = null;
                    }else if(o[i].constructor === Array){
                        //这是数组
                        c[i] =[]
                    }else{
                        //这是对象
                        c[i] = {}
                    }
                    deepCopy(o[i],c[i])
                }else{
                    c[i] = o[i]
                }
            }
            return c
        }
    </script>

</head>
<body style="margin: 0; overflow: hidden">

<div id="container">
    <canvas id="webglcanvas" width=800 height=600></canvas>
    <img class="sight" src="img/sight.png"/>
    <div class="tip"></div>
</div>
</body>
</html>

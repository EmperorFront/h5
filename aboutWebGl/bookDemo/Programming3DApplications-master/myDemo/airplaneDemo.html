<!DOCTYPE html>
<html lang="en">
<head>
    <title>airplane</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(#e4e0ba, #f7d9aa);
        }
    </style>
</head>
<body>

<script src="../libs/jquery-1.9.1/jquery-1.9.1.js"></script>
<script src="../libs/three.js.r58/threeDemoUse.js"></script>
<script src="../libs/three.js.r58/controls/OrbitControls.js"></script>
<script src="../libs/three.js.r58/controls/DeviceOrientationControls.js"></script>
<script src="../libs/requestAnimationFrame/RequestAnimationFrame.js"></script>


<div id="world"></div>



<script>
    //调色板
    var Colors = {
        red:0xf25346,
        white:0xd8d0d1,
        brown:0x59332e,
        pink:0xF5986E,
        brownDark:0x23190f,
        blue:0x68c3c0,
    };

    //一些全局变量
    var scene,camera,
            //相机垂直视角
            fieldOfView,
            //宽高比
            aspectRatio,
            //近裁剪面
            nearPlane,
            //远裁剪面
            farPlane,
            HEIGHT,
            WIDTH,
            renderer,
            container;

    function createScene() {
        // 获取场景的宽和高,用它们来设置相机的纵横比和渲染器的的尺寸
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;

        // 创建场景scene
        scene = new THREE.Scene();

        // 在场景中添加雾效; 颜色与css中背景颜色相同
        scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);

        // 创建摄像机camera
        aspectRatio = WIDTH / HEIGHT;
        fieldOfView = 60;
        nearPlane = 1;
        farPlane = 10000;
        camera = new THREE.PerspectiveCamera(
                fieldOfView,
                aspectRatio,
                nearPlane,
                farPlane
        );

        // 设置摄像机的坐标
        camera.position.x = -250;
        camera.position.z = 0;
        camera.position.y = 200;

        camera.lookAt({//相机看向哪个坐标
            x : 0,
            y : 100,
            z : 0
        });

        // 创建渲染器renderer
        renderer = new THREE.WebGLRenderer({
            // 允许背景透明，这样可以显示我们在css中定义的背景色
            alpha: true,

            // 开启抗锯齿效果; 性能变低,但是,因为我们的项目是基于低多边形的,应该还好
            antialias: true
        });

        // 定义渲染器的尺寸，此项目中它充满整个屏幕
        renderer.setSize(WIDTH, HEIGHT);

        // 启用阴影渲染
        renderer.shadowMap.enabled = true;

        // 将渲染器元素追加到我们在HTML里创建的容器元素里
        container = document.getElementById('world');
        container.appendChild(renderer.domElement);

        // 监听屏幕：如果用户改变屏幕尺寸，必须更新摄像机和渲染器的尺寸
        window.addEventListener('resize', handleWindowResize, false);
    }

    function handleWindowResize() {
        // 更新渲染器和摄像机的宽高
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
    }
    //添加光源
    var hemisphereLight, shadowLight;

    function createLights() {
        // 半球光HemisphereLight是渐变色光源；第一个参数是天空的颜色，第二个参数是地面的颜色，第三个参数是光源的强度
        hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9)

        // 平行光DirectionLight是从指定方向照射过来的光源。在此项目里用它来实现太阳光，所以它产生的光都是平行的
        shadowLight = new THREE.DirectionalLight(0xffffff, .9);

        // 设置光源的位置
        shadowLight.position.set(150, 350, 350);

        // 允许投射阴影
        shadowLight.castShadow = true;

        // 定义投射阴影的可见区域
        shadowLight.shadow.camera.left = -400;
        shadowLight.shadow.camera.right = 400;
        shadowLight.shadow.camera.top = 400;
        shadowLight.shadow.camera.bottom = -400;
        shadowLight.shadow.camera.near = 1;
        shadowLight.shadow.camera.far = 1000;

        // 定义阴影的分辨率; 越高越好，但性能也越低
        shadowLight.shadow.mapSize.width = 2048;
        shadowLight.shadow.mapSize.height = 2048;

        // 把光源添加到场景中激活它们
        scene.add(hemisphereLight);
        scene.add(shadowLight);
    }

    // 先定义一个大海对象:
    Sea = function(){

        // 创建一个圆柱形几何体Geometry;
        // 它的参数: 上表面半径，下表面半径，高度，对象的半径方向的细分线段数，对象的高度细分线段数
        var geom = new THREE.CylinderGeometry(600,600,800,40,10);

        // 让它在X轴上旋转
        geom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));

        // 创建材质Material
        var mat = new THREE.MeshPhongMaterial({
            color:Colors.blue,
            transparent:true,
            opacity:.6,
            shading:THREE.FlatShading,
        });

        // 在Three.js里创建一个物体Object，我们必须创建一个Mesh对象，Mesh对象就是Geometry创建的框架贴上材质Material最后形成的总体。
        this.mesh = new THREE.Mesh(geom, mat);

        // 允许大海接收阴影
        this.mesh.receiveShadow = true;
    }

    // 实例化大海对象，并把它添加到场景scene中:

    var sea;

    function createSea(){
        sea = new Sea();

        // 把它放到屏幕下方
        sea.mesh.position.y = -600;

        // 在场景中追加大海的Mesh对象
        scene.add(sea.mesh);
    }
    //创建云
    Cloud = function(){
        // 创建一个空的容器用来存放不同部分的云
        this.mesh = new THREE.Object3D();

        // 创建一个立方体;复制多个，来创建云
        var geom = new THREE.BoxGeometry(20,20,20);

        // 创建云的材质，简单的白色
        var mat = new THREE.MeshPhongMaterial({
            color:Colors.white,
        });

        // 随机定义要复制的几何体数量
        var nBlocs = 3+Math.floor(Math.random()*3);
        for (var i=0; i<nBlocs; i++ ){

            // 给复制的几何体创建Mesh对象
            var m = new THREE.Mesh(geom, mat);

            // 给每个立方体随机的设置位置和角度
            m.position.x = i*15;
            m.position.y = Math.random()*10;
            m.position.z = Math.random()*10;
            m.rotation.z = Math.random()*Math.PI*2;
            m.rotation.y = Math.random()*Math.PI*2;

            // 随机的设置立方体的尺寸
            var s = .1 + Math.random()*.9;
            m.scale.set(s,s,s);

            // 允许每朵云生成投影和接收投影
            m.castShadow = true;
            m.receiveShadow = true;

            // 把该立方体追加到上面我们创建的容器中
            this.mesh.add(m);
        }
    }

    // 定义天空对象
    Sky = function(){
        // 创建一个空的容器
        this.mesh = new THREE.Object3D();

        // 设定散落在天空中云朵的数量
        this.nClouds = 20;

        // To distribute the clouds consistently,
        // we need to place them according to a uniform angle
        var stepAngle = Math.PI*2 / this.nClouds;

        // 创建云朵
        for(var i=0; i<this.nClouds; i++){
            var c = new Cloud();

            // 给每朵云设置角度和位置;
            var a = stepAngle*i; // 云最终的角度
            var h = 750 + Math.random()*200; // 轴中心到云的距离

            // 将极坐标(角度、距离)转换成笛卡尔坐标(x,y)
            c.mesh.position.y = Math.sin(a)*h;
            c.mesh.position.x = Math.cos(a)*h;

            // 根据云的位置做旋转
            c.mesh.rotation.z = a + Math.PI/2;

            // 为了更真实，有远有近
            c.mesh.position.z = -400-Math.random()*400;

            // 给每朵云设置比例
            var s = 1+Math.random()*2;
            c.mesh.scale.set(s,s,s);

            // 将每朵云追加到场景中
            this.mesh.add(c.mesh);
        }
    }

    // 实例化天空对象，并把它的中心点放到屏幕下方

    var sky;

    function createSky(){
        sky = new Sky();
        sky.mesh.position.y = -600;
        scene.add(sky.mesh);
    }








    //创建飞机
    var AirPlane = function() {

        this.mesh = new THREE.Object3D();

        // 创建机舱
        var geomCockpit = new THREE.BoxGeometry(60,50,50,1,1,1);
        var matCockpit = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
        var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
        cockpit.castShadow = true;
        cockpit.receiveShadow = true;
        this.mesh.add(cockpit);

        // 创建发动机
        var geomEngine = new THREE.BoxGeometry(20,50,50,1,1,1);
        var matEngine = new THREE.MeshPhongMaterial({color:Colors.white, shading:THREE.FlatShading});
        var engine = new THREE.Mesh(geomEngine, matEngine);
        engine.position.x = 40;
        engine.castShadow = true;
        engine.receiveShadow = true;
        this.mesh.add(engine);

        // 创建机尾
        var geomTailPlane = new THREE.BoxGeometry(15,20,5,1,1,1);
        var matTailPlane = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
        var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);
        tailPlane.position.set(-35,25,0);
        tailPlane.castShadow = true;
        tailPlane.receiveShadow = true;
        this.mesh.add(tailPlane);

        // 创建机翼
        var geomSideWing = new THREE.BoxGeometry(40,8,150,1,1,1);
        var matSideWing = new THREE.MeshPhongMaterial({color:Colors.red, shading:THREE.FlatShading});
        var sideWing = new THREE.Mesh(geomSideWing, matSideWing);
        sideWing.castShadow = true;
        sideWing.receiveShadow = true;
        this.mesh.add(sideWing);

        // 创建螺旋桨
        var geomPropeller = new THREE.BoxGeometry(20,10,10,1,1,1);
        var matPropeller = new THREE.MeshPhongMaterial({color:Colors.brown, shading:THREE.FlatShading});
        this.propeller = new THREE.Mesh(geomPropeller, matPropeller);
        this.propeller.castShadow = true;
        this.propeller.receiveShadow = true;

        // blades
        var geomBlade = new THREE.BoxGeometry(1,100,20,1,1,1);
        var matBlade = new THREE.MeshPhongMaterial({color:Colors.brownDark, shading:THREE.FlatShading});

        var blade = new THREE.Mesh(geomBlade, matBlade);
        blade.position.set(8,0,0);
        blade.castShadow = true;
        blade.receiveShadow = true;
        this.propeller.add(blade);
        this.propeller.position.set(50,0,0);
        this.mesh.add(this.propeller);
    };

    var airplane;
    //将飞机追加到场景中去。
    function createPlane(){
        airplane = new AirPlane();
        airplane.mesh.scale.set(.25,.25,.25);
        airplane.mesh.position.y = 100;
        scene.add(airplane.mesh);
    }










    //鼠标位置
    var mousePos={x:0, y:0};

    // 处理鼠标移动事件

    function handleMouseMove(event) {

        // 将鼠标位置归一化到-1和1之间
        // 横轴的函数公式
        var tx = -1 + (event.clientX / WIDTH)*2;

        // 对宗轴来说，我们需求反函数，因为2D的y轴和3D的y轴方向相反

        var ty = 1 - (event.clientY / HEIGHT)*2;
        mousePos = {x:tx, y:ty};

    }

//    更新飞机位置
    function updatePlane(){

        // 根据鼠标x轴位置在-1到1之间，我们规定飞机x轴移动位置在-100到100之间，
        // 同样规定飞机y轴移动位置在25到175之间。

        var targetX = normalize(mousePos.x, -1, 1, -100, 100);
        var targetY = normalize(mousePos.y, -1, 1, 25, 175);

        // 更新飞机的位置
        airplane.mesh.position.y = targetY;
        airplane.mesh.position.x = targetX;
        airplane.propeller.rotation.x += 0.3;
    }

    function normalize(v,vmin,vmax,tmin, tmax){

        var nv = Math.max(Math.min(v,vmax), vmin);
        var dv = vmax-vmin;
        var pc = (nv-vmin)/dv;
        var dt = tmax-tmin;
        var tv = tmin + (pc*dt);
        return tv;

    }

    function loop(){
        // 转动螺旋桨、大海和天空
        airplane.propeller.rotation.x += 0.3;
        sea.mesh.rotation.z += .005;
        sky.mesh.rotation.z += .01;

        //更新飞机位置
        updatePlane();

        // 渲染场景
        renderer.render(scene, camera);

        // 再次调用loop函数
        requestAnimationFrame(loop);
    }

    window.addEventListener('load', init, false);

    function init() {
        // 设置场景scene,摄像机camera和渲染器renderer
        createScene();

        // 添加光源lights
        createLights();

        // 添加物体objects
        createPlane();
        createSea();
        createSky();


        //添加监听器
        document.addEventListener('mousemove', handleMouseMove, false);

        // 循环,将更新的物体的位置,并每一帧渲染场景
        loop();
    }
</script>



</body>
</html>